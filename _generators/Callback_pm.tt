#!/usr/bin/env perl

# BEWARE: this is a generated file, DO NOT EDIT THIS FILE MANUALLY!!!

package IUP::Internal::Callback;

use strict;
use warnings;
require DynaLoader;
our @ISA = qw/ DynaLoader /;

bootstrap IUP::Internal::Callback;

use IUP::Internal::LibraryIup;

my $cb_table = {
[% FOR i IN pmitems -%]
  '[% i.module %]' => {
[% FOR j IN i.actions -%]
    [% j.action %] => \&[% j.xs_init_cb %],
[% END -%]
  },
[% END -%]
};

# xxx TODO xxx: maybe return something else then -1 in case of error

sub _execute_cb { # convert just the first arg from ihandle to objref
  my ($ih, $action, @args) = @_;
  my $ref = IUP::Internal::LibraryIup::_translate_ih($ih);         # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($ih);
  return -1 unless ref($ref);
  my $func = $ref->{$action};
  return -1 unless (ref($func) eq 'CODE');
  my $rv = &$func($ref, @args);
  return -1 unless defined $rv;
  return $rv;
}

sub _execute_cb_ih3 {  #Ihandle* ih,int lin,int col,Ihandle* drop,char* t,int i,int v
  my ($ih, $action, @args) = @_;
  my $ref = IUP::Internal::LibraryIup::_translate_ih($ih);          # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($ih);
  return -1 unless ref($ref);
  $args[2] = IUP::Internal::LibraryIup::_translate_ih($args[2]);    # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($args[2]);
  return -1 unless ref($args[2]);
  my $func = $ref->{$action};
  return -1 unless (ref($func) eq 'CODE');
  my $rv = &$func($ref, @args);
  return -1 unless defined $rv;
  return $rv;
}

sub _execute_cb_ih1 {  #Ihandle* ih,Ihandle* drop,int lin,int col
  my ($ih, $action, @args) = @_;
  my $ref = IUP::Internal::LibraryIup::_translate_ih($ih);          # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($ih);
  return -1 unless ref($ref);
  $args[0] = IUP::Internal::LibraryIup::_translate_ih($args[0]);    # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($args[0]);
  return -1 unless ref($args[0]);
  my $func = $ref->{$action};
  return -1 unless (ref($func) eq 'CODE');
  my $rv = &$func($ref, @args);
  return -1 unless defined $rv;
  return $rv;
}

sub _execute_cb_ih12 { #Ihandle* ih,Ihandle* new_tab,Ihandle* old_tab
  my ($ih, $action, @args) = @_;
  my $ref = IUP::Internal::LibraryIup::_translate_ih($ih);          # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($ih);
  return -1 unless ref($ref);
  $args[0] = IUP::Internal::LibraryIup::_translate_ih($args[0]);    # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($args[0]);
  return -1 unless ref($args[0]);
  $args[1] = IUP::Internal::LibraryIup::_translate_ih($args[1]);    # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($args[1]);
  return -1 unless ref($args[1]);
  my $func = $ref->{$action};
  return -1 unless (ref($func) eq 'CODE');
  my $rv = &$func($ref, @args);
  return -1 unless defined $rv;
  return $rv;
}

sub _execute_cb_cnv7 { #Ihandle* ih,int line,int column,int xmin,int xmax,int ymin,int ymax,cdCanvas* canvas
  my ($ih, $action, @args) = @_;
  my $ref = IUP::Internal::LibraryIup::_translate_ih($ih);          # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($ih);
  return -1 unless ref($ref);
  warn "### xxx TODO xxx _execute_cb_cnv7(): do not know how to convert canvas handle ($args[6])";
  my $func = $ref->{$action};
  return -1 unless (ref($func) eq 'CODE');
  my $rv = &$func($ref, @args);
  return -1 unless defined $rv;
  return $rv;
}

sub _execute_cb_cnv1 { #Ihandle* ih,cdCanvas* cnv
  my ($ih, $action, @args) = @_;
  my $ref = IUP::Internal::LibraryIup::_translate_ih($ih);          # xxx TODO xxx maybe IUP->GetOrCreateByIhandle($ih);
  return -1 unless ref($ref);
  warn "### xxx TODO xxx _execute_cb_cnv1(): do not know how to convert canvas handle ($args[0])";
  my $func = $ref->{$action};
  return -1 unless (ref($func) eq 'CODE');
  my $rv = &$func($ref, @args);
  return -1 unless defined $rv;
  return $rv;
}

sub _get_cb_init_function {
  my ($pkg, $action) = @_;
  my $rv = $cb_table->{$pkg};
  return unless defined $rv;
  my $f = $rv->{$action};
  # xxx TODO xxx add support for K_* callbacks
  #if (!$f && $action =~ /^K_/) {
  #  $f = $rv->{K_ANY};
  #}
  return $f;
}

sub _is_cb_valid {
  my ($pkg, $action) = @_;
  my $h = $cb_table->{$pkg};
  return 0 unless defined($h);
  return defined($h->{$action}) ? 1 : 0;
}

sub _get_cb_list {
  my ($element) = @_;
  my $h = $cb_table->{$element} or return;
  return keys %$h;
}

sub _get_cb_eval_code {
  my ($element, $p) = @_;
  my $rv = '';
  my $h = $cb_table->{$element} or return $rv;
  
  for (keys %$h) {
    next if defined *{"$p\::$_"};
    # xxx TODO xxx: making rw accessors for callbacks does not make much sense
    $rv .= "*$p\::$_ = sub { return \$_[1] ? \$_[0]->SetCallback('$_', \$_[1]) : \$_[0]->{$_} };\n";
  }

  return $rv;
}

1;

__END__

=head1 NAME

IUP::Internal::Callback - INTERNAL FUNCTIONS, do not use them from outside!

=cut
