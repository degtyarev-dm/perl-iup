/* BEWARE: this is a generated file, DO NOT EDIT THIS FILE MANUALLY!!! */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"

#include <iup.h>
#include <cd.h>

SV* canvas2SV(cdCanvas* canvas) {
  SV* ptrSV = newSViv(PTR2IV(canvas));
  char* hkey = SvPV_nolen(ptrSV);
  HV* globreg = get_hv("IUP::Internal::LibraryIup::ch_register", 0);

  /* ### check if canvas pointer is present in global hash 'ch_register' */
  SV** ref = hv_fetch(globreg, hkey, strlen(hkey), 0);
  if (ref != NULL) return *ref;

  /* ### http://stackoverflow.com/questions/1497836/how-do-i-write-a-perl-constructor-in-xs */
  /*warn("DEBUG: need to create IUP::Internal::Canvas %s\n",hkey);*/
  HV* hash = (HV *)sv_2mortal((SV *)newHV());
  SV* obj = sv_bless( newRV((SV*)hash), gv_stashpv("IUP::Internal::Canvas", 1) );
  hv_store(hash, "___cnvhandle", 12, ptrSV, 0);
  hv_store(globreg, hkey, strlen(hkey), newSVsv(obj), 0); /*store into globreg*/
  return sv_2mortal(obj);
}

SV* ihandle2SV(Ihandle* ih) {  
  SV* ptrSV = newSViv(PTR2IV(ih));
  char* hkey = SvPV_nolen(ptrSV);
  HV* globreg = get_hv("IUP::Internal::LibraryIup::ih_register", 0);

  /* ### check if canvas pointer is present in global hash 'ih_register' */
  SV** ref = hv_fetch(globreg, hkey, strlen(hkey), 0);
  if (ref != NULL) return *ref;
  
  /* ### http://stackoverflow.com/questions/1497836/how-do-i-write-a-perl-constructor-in-xs */
  /*warn("DEBUG: need to create IUP::Internal::Element %s\n",hkey);*/
  HV* hash = (HV *)sv_2mortal((SV *)newHV());
  SV* obj = sv_bless( newRV((SV*)hash), gv_stashpv("IUP::Internal::Element", 1) );
  hv_store(hash, "___ihandle", 10, ptrSV, 0);
  hv_store(globreg, hkey, strlen(hkey), newSVsv(obj), 0); /*store into globreg*/
  return sv_2mortal(obj);
}

int call_cb_func(SV* element, char *action) {
  /* call_pv(element->{action},G_ARRAY) */
  HV* hash = MUTABLE_HV(SvRV(element));
  SV** ref = hv_fetch(hash, action, strlen(action), 0);
  if (ref != NULL) return call_sv(*ref,G_ARRAY);
  return -1; /*xxxCHECKLATER not sure if -1 is a good idea*/
}

int
internal_cb_ACTION_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"ACTION");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_BUTTON_CB_iiiis (Ihandle* ih,int button,int pressed,int x,int y,char* status)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(button)));
	XPUSHs(sv_2mortal(newSViv(pressed)));
	XPUSHs(sv_2mortal(newSViv(x)));
	XPUSHs(sv_2mortal(newSViv(y)));
	XPUSHs(sv_2mortal(newSVpv(status, 0)));
	PUTBACK;

	count = call_cb_func(element,"BUTTON_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_RESIZE_CB_ii (Ihandle* ih,int width,int height)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(width)));
	XPUSHs(sv_2mortal(newSViv(height)));
	PUTBACK;

	count = call_cb_func(element,"RESIZE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DRAW_CB_iiiiiiv (Ihandle* ih,int line,int column,int xmin,int xmax,int ymin,int ymax,cdCanvas* canvas)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb_cnv7() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(line)));
	XPUSHs(sv_2mortal(newSViv(column)));
	XPUSHs(sv_2mortal(newSViv(xmin)));
	XPUSHs(sv_2mortal(newSViv(xmax)));
	XPUSHs(sv_2mortal(newSViv(ymin)));
	XPUSHs(sv_2mortal(newSViv(ymax)));
	XPUSHs(canvas2SV(canvas));
	PUTBACK;

	count = call_cb_func(element,"DRAW_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_HEIGHT_CB_i (Ihandle* ih,int line)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(line)));
	PUTBACK;

	count = call_cb_func(element,"HEIGHT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_HSPAN_CB_ii (Ihandle* ih,int line,int column)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(line)));
	XPUSHs(sv_2mortal(newSViv(column)));
	PUTBACK;

	count = call_cb_func(element,"HSPAN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MOUSECLICK_CB_iiiiiis (Ihandle* ih,int button,int pressed,int line,int column,int x,int y,char* status)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(button)));
	XPUSHs(sv_2mortal(newSViv(pressed)));
	XPUSHs(sv_2mortal(newSViv(line)));
	XPUSHs(sv_2mortal(newSViv(column)));
	XPUSHs(sv_2mortal(newSViv(x)));
	XPUSHs(sv_2mortal(newSViv(y)));
	XPUSHs(sv_2mortal(newSVpv(status, 0)));
	PUTBACK;

	count = call_cb_func(element,"MOUSECLICK_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MOUSEMOTION_CB_iiiis (Ihandle* ih,int line,int column,int x,int y,char* r)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(line)));
	XPUSHs(sv_2mortal(newSViv(column)));
	XPUSHs(sv_2mortal(newSViv(x)));
	XPUSHs(sv_2mortal(newSViv(y)));
	XPUSHs(sv_2mortal(newSVpv(r, 0)));
	PUTBACK;

	count = call_cb_func(element,"MOUSEMOTION_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_NCOLS_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"NCOLS_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_NLINES_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"NLINES_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SCROLLING_CB_ii (Ihandle* ih,int line,int column)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(line)));
	XPUSHs(sv_2mortal(newSViv(column)));
	PUTBACK;

	count = call_cb_func(element,"SCROLLING_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_VSPAN_CB_ii (Ihandle* ih,int line,int column)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(line)));
	XPUSHs(sv_2mortal(newSViv(column)));
	PUTBACK;

	count = call_cb_func(element,"VSPAN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_WIDTH_CB_i (Ihandle* ih,int column)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(column)));
	PUTBACK;

	count = call_cb_func(element,"WIDTH_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

char*
internal_cb_CELL_CB_i (Ihandle* ih,int cell)
{
	dSP;
	int count;
	char* rv = NULL;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(cell)));
	PUTBACK;

	count = call_cb_func(element,"CELL_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPpx;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_EXTENDED_CB_i (Ihandle* ih,int cell)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(cell)));
	PUTBACK;

	count = call_cb_func(element,"EXTENDED_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SELECT_CB_ii (Ihandle* ih,int cell,int type)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(cell)));
	XPUSHs(sv_2mortal(newSViv(type)));
	PUTBACK;

	count = call_cb_func(element,"SELECT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SWITCH_CB_ii (Ihandle* ih,int prim_cell,int sec_cell)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(prim_cell)));
	XPUSHs(sv_2mortal(newSViv(sec_cell)));
	PUTBACK;

	count = call_cb_func(element,"SWITCH_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_CHANGE_CB_ccc (Ihandle* ih,unsigned char r,unsigned char g,unsigned char b)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(r)));
	XPUSHs(sv_2mortal(newSViv(g)));
	XPUSHs(sv_2mortal(newSViv(b)));
	PUTBACK;

	count = call_cb_func(element,"CHANGE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DRAG_CB_ccc (Ihandle* ih,unsigned char r,unsigned char g,unsigned char b)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(r)));
	XPUSHs(sv_2mortal(newSViv(g)));
	XPUSHs(sv_2mortal(newSViv(b)));
	PUTBACK;

	count = call_cb_func(element,"DRAG_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_VALUECHANGED_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"VALUECHANGED_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_BUTTON_PRESS_CB_d (Ihandle* ih,double angle)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVnv(angle)));
	PUTBACK;

	count = call_cb_func(element,"BUTTON_PRESS_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_BUTTON_RELEASE_CB_d (Ihandle* ih,double angle)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVnv(angle)));
	PUTBACK;

	count = call_cb_func(element,"BUTTON_RELEASE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MOUSEMOVE_CB_d (Ihandle* ih,double angle)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVnv(angle)));
	PUTBACK;

	count = call_cb_func(element,"MOUSEMOVE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_FILE_CB_ss (Ihandle* ih,const char* file_name,const char* status)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVpv(file_name, 0)));
	XPUSHs(sv_2mortal(newSVpv(status, 0)));
	PUTBACK;

	count = call_cb_func(element,"FILE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_HIGHLIGHT_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"HIGHLIGHT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DROPFILES_CB_siii (Ihandle* ih,const char* filename,int num,int x,int y)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVpv(filename, 0)));
	XPUSHs(sv_2mortal(newSViv(num)));
	XPUSHs(sv_2mortal(newSViv(x)));
	XPUSHs(sv_2mortal(newSViv(y)));
	PUTBACK;

	count = call_cb_func(element,"DROPFILES_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_ACTION_sii (Ihandle* ih,char* text,int item,int state)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVpv(text, 0)));
	XPUSHs(sv_2mortal(newSViv(item)));
	XPUSHs(sv_2mortal(newSViv(state)));
	PUTBACK;

	count = call_cb_func(element,"ACTION");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_CARET_CB_iii (Ihandle* ih,int lin,int col,int pos)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	XPUSHs(sv_2mortal(newSViv(pos)));
	PUTBACK;

	count = call_cb_func(element,"CARET_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DBLCLICK_CB_is (Ihandle* ih,int item,char* text)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(item)));
	XPUSHs(sv_2mortal(newSVpv(text, 0)));
	PUTBACK;

	count = call_cb_func(element,"DBLCLICK_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DROPDOWN_CB_i (Ihandle* ih,int state)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(state)));
	PUTBACK;

	count = call_cb_func(element,"DROPDOWN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_EDIT_CB_is (Ihandle* ih,int c,char* new_value)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(c)));
	XPUSHs(sv_2mortal(newSVpv(new_value, 0)));
	PUTBACK;

	count = call_cb_func(element,"EDIT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MOTION_CB_iis (Ihandle* ih,int x,int y,char* status)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(x)));
	XPUSHs(sv_2mortal(newSViv(y)));
	XPUSHs(sv_2mortal(newSVpv(status, 0)));
	PUTBACK;

	count = call_cb_func(element,"MOTION_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MULTISELECT_CB_s (Ihandle* ih,char* value)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVpv(value, 0)));
	PUTBACK;

	count = call_cb_func(element,"MULTISELECT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_ACTION_CB_iiiis (Ihandle* ih,int c,int lin,int col,int edition,char* after)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(c)));
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	XPUSHs(sv_2mortal(newSViv(edition)));
	XPUSHs(sv_2mortal(newSVpv(after, 0)));
	PUTBACK;

	count = call_cb_func(element,"ACTION_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_BGCOLOR_CB_iiIII (Ihandle* ih,int lin,int col,unsigned int* red,unsigned int* green,unsigned int* blue)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"BGCOLOR_CB");

	SPAGAIN;

	if (count != 4) { warn("Warning: BGCOLOR_CB callback has not returned 4 values (count=%d)!\n",count); }
	else {
	  *blue = POPi;
	  *green = POPi;
	  *red = POPi;
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_CLICK_CB_iis (Ihandle* ih,int lin,int col,char* status)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	XPUSHs(sv_2mortal(newSVpv(status, 0)));
	PUTBACK;

	count = call_cb_func(element,"CLICK_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DROPCHECK_CB_ii (Ihandle* ih,int lin,int col)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"DROPCHECK_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DROPSELECT_CB_iinsii (Ihandle* ih,int lin,int col,Ihandle* drop,char* t,int i,int v)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb_ih3() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	XPUSHs(ihandle2SV(drop));
	XPUSHs(sv_2mortal(newSVpv(t, 0)));
	XPUSHs(sv_2mortal(newSViv(i)));
	XPUSHs(sv_2mortal(newSViv(v)));
	PUTBACK;

	count = call_cb_func(element,"DROPSELECT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DROP_CB_nii (Ihandle* ih,Ihandle* drop,int lin,int col)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb_ih1() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(ihandle2SV(drop));
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"DROP_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_EDITION_CB_iiii (Ihandle* ih,int lin,int col,int mode,int update)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	XPUSHs(sv_2mortal(newSViv(mode)));
	XPUSHs(sv_2mortal(newSViv(update)));
	PUTBACK;

	count = call_cb_func(element,"EDITION_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_ENTERITEM_CB_ii (Ihandle* ih,int lin,int col)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"ENTERITEM_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_FGCOLOR_CB_iiIII (Ihandle* ih,int lin,int col,unsigned int* red,unsigned int* green,unsigned int* blue)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"FGCOLOR_CB");

	SPAGAIN;

	if (count != 4) { warn("Warning: FGCOLOR_CB callback has not returned 4 values (count=%d)!\n",count); }
	else {
	  *blue = POPi;
	  *green = POPi;
	  *red = POPi;
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

char*
internal_cb_FONT_CB_ii (Ihandle* ih,int lin,int col)
{
	dSP;
	int count;
	char* rv = NULL;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"FONT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPpx;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_LEAVEITEM_CB_ii (Ihandle* ih,int lin,int col)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"LEAVEITEM_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MARKEDIT_CB_iii (Ihandle* ih,int lin,int col,int marked)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	XPUSHs(sv_2mortal(newSViv(marked)));
	PUTBACK;

	count = call_cb_func(element,"MARKEDIT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MARK_CB_ii (Ihandle* ih,int lin,int col)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"MARK_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MOUSEMOVE_CB_ii (Ihandle* ih,int lin,int col)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"MOUSEMOVE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_RELEASE_CB_iis (Ihandle* ih,int lin,int col,char* status)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	XPUSHs(sv_2mortal(newSVpv(status, 0)));
	PUTBACK;

	count = call_cb_func(element,"RELEASE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SCROLLTOP_CB_ii (Ihandle* ih,int lin,int col)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"SCROLLTOP_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

char*
internal_cb_VALUE_CB_ii (Ihandle* ih,int lin,int col)
{
	dSP;
	int count;
	char* rv = NULL;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	PUTBACK;

	count = call_cb_func(element,"VALUE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPpx;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_VALUE_EDIT_CB_iis (Ihandle* ih,int lin,int col,char* newval)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(lin)));
	XPUSHs(sv_2mortal(newSViv(col)));
	XPUSHs(sv_2mortal(newSVpv(newval, 0)));
	PUTBACK;

	count = call_cb_func(element,"VALUE_EDIT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MENUCLOSE_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"MENUCLOSE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_OPEN_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"OPEN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DELETEBEGIN_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"DELETEBEGIN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DELETEEND_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"DELETEEND_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DELETE_CB_iiff (Ihandle* ih,int index,int sample_index,float x,float y)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(index)));
	XPUSHs(sv_2mortal(newSViv(sample_index)));
	XPUSHs(sv_2mortal(newSVnv(x)));
	XPUSHs(sv_2mortal(newSVnv(y)));
	PUTBACK;

	count = call_cb_func(element,"DELETE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_EDITBEGIN_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"EDITBEGIN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_EDITEND_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"EDITEND_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_EDIT_CB_iiffFF (Ihandle* ih,int index,int sample_index,float x,float y,float* new_x,float* new_y)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(index)));
	XPUSHs(sv_2mortal(newSViv(sample_index)));
	XPUSHs(sv_2mortal(newSVnv(x)));
	XPUSHs(sv_2mortal(newSVnv(y)));
	PUTBACK;

	count = call_cb_func(element,"EDIT_CB");

	SPAGAIN;

	if (count != 3) { warn("Warning: EDIT_CB callback has not returned 3 values (count=%d)!\n",count); }
	else {
	  *new_y = POPn;
	  *new_x = POPn;
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_POSTDRAW_CB_v (Ihandle* ih,cdCanvas* cnv)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb_cnv1() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(canvas2SV(cnv));
	PUTBACK;

	count = call_cb_func(element,"POSTDRAW_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_PREDRAW_CB_v (Ihandle* ih,cdCanvas* cnv)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb_cnv1() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(canvas2SV(cnv));
	PUTBACK;

	count = call_cb_func(element,"PREDRAW_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SELECTBEGIN_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"SELECTBEGIN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SELECTEND_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"SELECTEND_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SELECT_CB_iiffi (Ihandle* ih,int index,int sample_index,float x,float y,int select)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(index)));
	XPUSHs(sv_2mortal(newSViv(sample_index)));
	XPUSHs(sv_2mortal(newSVnv(x)));
	XPUSHs(sv_2mortal(newSVnv(y)));
	XPUSHs(sv_2mortal(newSViv(select)));
	PUTBACK;

	count = call_cb_func(element,"SELECT_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SPIN_CB_i (Ihandle* ih,int inc)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(inc)));
	PUTBACK;

	count = call_cb_func(element,"SPIN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_TABCHANGEPOS_CB_ii (Ihandle* ih,int new_pos,int old_pos)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(new_pos)));
	XPUSHs(sv_2mortal(newSViv(old_pos)));
	PUTBACK;

	count = call_cb_func(element,"TABCHANGEPOS_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_TABCHANGE_CB_nn (Ihandle* ih,Ihandle* new_tab,Ihandle* old_tab)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb_ih12() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(ihandle2SV(new_tab));
	XPUSHs(ihandle2SV(old_tab));
	PUTBACK;

	count = call_cb_func(element,"TABCHANGE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_ACTION_is (Ihandle* ih,int c,char* new_value)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(c)));
	XPUSHs(sv_2mortal(newSVpv(new_value, 0)));
	PUTBACK;

	count = call_cb_func(element,"ACTION");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_ACTION_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"ACTION_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_ACTION_i (Ihandle* ih,int state)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(state)));
	PUTBACK;

	count = call_cb_func(element,"ACTION");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_BRANCHCLOSE_CB_i (Ihandle* ih,int id)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(id)));
	PUTBACK;

	count = call_cb_func(element,"BRANCHCLOSE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_BRANCHOPEN_CB_i (Ihandle* ih,int id)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(id)));
	PUTBACK;

	count = call_cb_func(element,"BRANCHOPEN_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_DRAGDROP_CB_iiii (Ihandle* ih,int drag_id,int drop_id,int isshift,int iscontrol)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(drag_id)));
	XPUSHs(sv_2mortal(newSViv(drop_id)));
	XPUSHs(sv_2mortal(newSViv(isshift)));
	XPUSHs(sv_2mortal(newSViv(iscontrol)));
	PUTBACK;

	count = call_cb_func(element,"DRAGDROP_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_EXECUTELEAF_CB_i (Ihandle* ih,int id)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(id)));
	PUTBACK;

	count = call_cb_func(element,"EXECUTELEAF_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MULTISELECTION_CB_Ai (Ihandle* ih,int* ids,int n)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);
	int loc_i;

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	for(loc_i=0; loc_i<n; loc_i++) XPUSHs(sv_2mortal(newSViv(ids[loc_i])));
	PUTBACK;

	count = call_cb_func(element,"MULTISELECTION_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MULTIUNSELECTION_CB_Ai (Ihandle* ih,int* ids,int n)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);
	int loc_i;

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	for(loc_i=0; loc_i<n; loc_i++) XPUSHs(sv_2mortal(newSViv(ids[loc_i])));
	PUTBACK;

	count = call_cb_func(element,"MULTIUNSELECTION_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_NODEREMOVED_CB_s (Ihandle* ih,void* userdata)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVpv(userdata, 0)));
	PUTBACK;

	count = call_cb_func(element,"NODEREMOVED_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_RENAME_CB_is (Ihandle* ih,int id,char* title)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(id)));
	XPUSHs(sv_2mortal(newSVpv(title, 0)));
	PUTBACK;

	count = call_cb_func(element,"RENAME_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_RIGHTCLICK_CB_i (Ihandle* ih,int id)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(id)));
	PUTBACK;

	count = call_cb_func(element,"RIGHTCLICK_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SELECTION_CB_ii (Ihandle* ih,int id,int status)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(id)));
	XPUSHs(sv_2mortal(newSViv(status)));
	PUTBACK;

	count = call_cb_func(element,"SELECTION_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SHOWRENAME_CB_i (Ihandle* ih,int id)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(id)));
	PUTBACK;

	count = call_cb_func(element,"SHOWRENAME_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_ENTERWINDOW_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"ENTERWINDOW_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_GETFOCUS_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"GETFOCUS_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_HELP_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"HELP_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_KILLFOCUS_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"KILLFOCUS_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_K_ANY_i (Ihandle* ih,int c)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(c)));
	PUTBACK;

	count = call_cb_func(element,"K_ANY");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_LEAVEWINDOW_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"LEAVEWINDOW_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MAP_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"MAP_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_UNMAP_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"UNMAP_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_ACTION_ff (Ihandle* ih,float posx,float posy)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVnv(posx)));
	XPUSHs(sv_2mortal(newSVnv(posy)));
	PUTBACK;

	count = call_cb_func(element,"ACTION");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_FOCUS_CB_i (Ihandle* ih,int focus)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(focus)));
	PUTBACK;

	count = call_cb_func(element,"FOCUS_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_KEYPRESS_CB_ii (Ihandle* ih,int c,int press)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(c)));
	XPUSHs(sv_2mortal(newSViv(press)));
	PUTBACK;

	count = call_cb_func(element,"KEYPRESS_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MULTITOUCH_CB_iIIII (Ihandle* ih,int count_,int* pid,int* px,int* py,int* pstate)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(count_)));
	PUTBACK;

	count = call_cb_func(element,"MULTITOUCH_CB");

	SPAGAIN;

	if (count != 5) { warn("Warning: MULTITOUCH_CB callback has not returned 5 values (count=%d)!\n",count); }
	else {
	  *pstate = POPi;
	  *py = POPi;
	  *px = POPi;
	  *pid = POPi;
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SCROLL_CB_iff (Ihandle* ih,int op,float posx,float posy)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(op)));
	XPUSHs(sv_2mortal(newSVnv(posx)));
	XPUSHs(sv_2mortal(newSVnv(posy)));
	PUTBACK;

	count = call_cb_func(element,"SCROLL_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_TOUCH_CB_iiis (Ihandle* ih,int id,int x,int y,char* state)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(id)));
	XPUSHs(sv_2mortal(newSViv(x)));
	XPUSHs(sv_2mortal(newSViv(y)));
	XPUSHs(sv_2mortal(newSVpv(state, 0)));
	PUTBACK;

	count = call_cb_func(element,"TOUCH_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_WHEEL_CB_fiis (Ihandle* ih,float delta,int x,int y,char* status)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVnv(delta)));
	XPUSHs(sv_2mortal(newSViv(x)));
	XPUSHs(sv_2mortal(newSViv(y)));
	XPUSHs(sv_2mortal(newSVpv(status, 0)));
	PUTBACK;

	count = call_cb_func(element,"WHEEL_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_WOM_CB_i (Ihandle* ih,int state)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(state)));
	PUTBACK;

	count = call_cb_func(element,"WOM_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_CLOSE_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"CLOSE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_COPYDATA_CB_si (Ihandle* ih,char* cmdLine,int size)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSVpv(cmdLine, 0)));
	XPUSHs(sv_2mortal(newSViv(size)));
	PUTBACK;

	count = call_cb_func(element,"COPYDATA_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MDIACTIVATE_CB_ (Ihandle* ih)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	PUTBACK;

	count = call_cb_func(element,"MDIACTIVATE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_MOVE_CB_ii (Ihandle* ih,int x,int y)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(x)));
	XPUSHs(sv_2mortal(newSViv(y)));
	PUTBACK;

	count = call_cb_func(element,"MOVE_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_SHOW_CB_i (Ihandle* ih,int state)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(state)));
	PUTBACK;

	count = call_cb_func(element,"SHOW_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 

int
internal_cb_TRAYCLICK_CB_iii (Ihandle* ih,int but,int pressed,int dclick)
{
	dSP;
	int count;
	int rv = IUP_DEFAULT;
	SV* element = ihandle2SV(ih);

	ENTER;
	SAVETMPS;

	/* push params for _execute_cb() */
	PUSHMARK(SP);
	XPUSHs(element);
	XPUSHs(sv_2mortal(newSViv(but)));
	XPUSHs(sv_2mortal(newSViv(pressed)));
	XPUSHs(sv_2mortal(newSViv(dclick)));
	PUTBACK;

	count = call_cb_func(element,"TRAYCLICK_CB");

	SPAGAIN;

	if (count != 1) { /* no warning, use default retval */ }
	else {
	  rv = POPi;
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
	
	return rv;
} 


MODULE = IUP::Internal::Callback	PACKAGE = IUP::Internal::Callback

BOOT:
/* empty boot */


void
_init_cb_ACTION_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ACTION_);

void
_init_cb_BUTTON_CB_iiiis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_BUTTON_CB_iiiis);

void
_init_cb_RESIZE_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_RESIZE_CB_ii);

void
_init_cb_DRAW_CB_iiiiiiv(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DRAW_CB_iiiiiiv);

void
_init_cb_HEIGHT_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_HEIGHT_CB_i);

void
_init_cb_HSPAN_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_HSPAN_CB_ii);

void
_init_cb_MOUSECLICK_CB_iiiiiis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MOUSECLICK_CB_iiiiiis);

void
_init_cb_MOUSEMOTION_CB_iiiis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MOUSEMOTION_CB_iiiis);

void
_init_cb_NCOLS_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_NCOLS_CB_);

void
_init_cb_NLINES_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_NLINES_CB_);

void
_init_cb_SCROLLING_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SCROLLING_CB_ii);

void
_init_cb_VSPAN_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_VSPAN_CB_ii);

void
_init_cb_WIDTH_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_WIDTH_CB_i);

void
_init_cb_CELL_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_CELL_CB_i);

void
_init_cb_EXTENDED_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_EXTENDED_CB_i);

void
_init_cb_SELECT_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SELECT_CB_ii);

void
_init_cb_SWITCH_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SWITCH_CB_ii);

void
_init_cb_CHANGE_CB_ccc(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_CHANGE_CB_ccc);

void
_init_cb_DRAG_CB_ccc(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DRAG_CB_ccc);

void
_init_cb_VALUECHANGED_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_VALUECHANGED_CB_);

void
_init_cb_BUTTON_PRESS_CB_d(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_BUTTON_PRESS_CB_d);

void
_init_cb_BUTTON_RELEASE_CB_d(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_BUTTON_RELEASE_CB_d);

void
_init_cb_MOUSEMOVE_CB_d(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MOUSEMOVE_CB_d);

void
_init_cb_FILE_CB_ss(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_FILE_CB_ss);

void
_init_cb_HIGHLIGHT_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_HIGHLIGHT_CB_);

void
_init_cb_DROPFILES_CB_siii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DROPFILES_CB_siii);

void
_init_cb_ACTION_sii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ACTION_sii);

void
_init_cb_CARET_CB_iii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_CARET_CB_iii);

void
_init_cb_DBLCLICK_CB_is(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DBLCLICK_CB_is);

void
_init_cb_DROPDOWN_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DROPDOWN_CB_i);

void
_init_cb_EDIT_CB_is(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_EDIT_CB_is);

void
_init_cb_MOTION_CB_iis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MOTION_CB_iis);

void
_init_cb_MULTISELECT_CB_s(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MULTISELECT_CB_s);

void
_init_cb_ACTION_CB_iiiis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ACTION_CB_iiiis);

void
_init_cb_BGCOLOR_CB_iiIII(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_BGCOLOR_CB_iiIII);

void
_init_cb_CLICK_CB_iis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_CLICK_CB_iis);

void
_init_cb_DROPCHECK_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DROPCHECK_CB_ii);

void
_init_cb_DROPSELECT_CB_iinsii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DROPSELECT_CB_iinsii);

void
_init_cb_DROP_CB_nii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DROP_CB_nii);

void
_init_cb_EDITION_CB_iiii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_EDITION_CB_iiii);

void
_init_cb_ENTERITEM_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ENTERITEM_CB_ii);

void
_init_cb_FGCOLOR_CB_iiIII(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_FGCOLOR_CB_iiIII);

void
_init_cb_FONT_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_FONT_CB_ii);

void
_init_cb_LEAVEITEM_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_LEAVEITEM_CB_ii);

void
_init_cb_MARKEDIT_CB_iii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MARKEDIT_CB_iii);

void
_init_cb_MARK_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MARK_CB_ii);

void
_init_cb_MOUSEMOVE_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MOUSEMOVE_CB_ii);

void
_init_cb_RELEASE_CB_iis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_RELEASE_CB_iis);

void
_init_cb_SCROLLTOP_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SCROLLTOP_CB_ii);

void
_init_cb_VALUE_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_VALUE_CB_ii);

void
_init_cb_VALUE_EDIT_CB_iis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_VALUE_EDIT_CB_iis);

void
_init_cb_MENUCLOSE_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MENUCLOSE_CB_);

void
_init_cb_OPEN_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_OPEN_CB_);

void
_init_cb_DELETEBEGIN_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DELETEBEGIN_CB_);

void
_init_cb_DELETEEND_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DELETEEND_CB_);

void
_init_cb_DELETE_CB_iiff(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DELETE_CB_iiff);

void
_init_cb_EDITBEGIN_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_EDITBEGIN_CB_);

void
_init_cb_EDITEND_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_EDITEND_CB_);

void
_init_cb_EDIT_CB_iiffFF(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_EDIT_CB_iiffFF);

void
_init_cb_POSTDRAW_CB_v(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_POSTDRAW_CB_v);

void
_init_cb_PREDRAW_CB_v(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_PREDRAW_CB_v);

void
_init_cb_SELECTBEGIN_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SELECTBEGIN_CB_);

void
_init_cb_SELECTEND_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SELECTEND_CB_);

void
_init_cb_SELECT_CB_iiffi(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SELECT_CB_iiffi);

void
_init_cb_SPIN_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SPIN_CB_i);

void
_init_cb_TABCHANGEPOS_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_TABCHANGEPOS_CB_ii);

void
_init_cb_TABCHANGE_CB_nn(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_TABCHANGE_CB_nn);

void
_init_cb_ACTION_is(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ACTION_is);

void
_init_cb_ACTION_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ACTION_CB_);

void
_init_cb_ACTION_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ACTION_i);

void
_init_cb_BRANCHCLOSE_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_BRANCHCLOSE_CB_i);

void
_init_cb_BRANCHOPEN_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_BRANCHOPEN_CB_i);

void
_init_cb_DRAGDROP_CB_iiii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_DRAGDROP_CB_iiii);

void
_init_cb_EXECUTELEAF_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_EXECUTELEAF_CB_i);

void
_init_cb_MULTISELECTION_CB_Ai(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MULTISELECTION_CB_Ai);

void
_init_cb_MULTIUNSELECTION_CB_Ai(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MULTIUNSELECTION_CB_Ai);

void
_init_cb_NODEREMOVED_CB_s(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_NODEREMOVED_CB_s);

void
_init_cb_RENAME_CB_is(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_RENAME_CB_is);

void
_init_cb_RIGHTCLICK_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_RIGHTCLICK_CB_i);

void
_init_cb_SELECTION_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SELECTION_CB_ii);

void
_init_cb_SHOWRENAME_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SHOWRENAME_CB_i);

void
_init_cb_ENTERWINDOW_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ENTERWINDOW_CB_);

void
_init_cb_GETFOCUS_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_GETFOCUS_CB_);

void
_init_cb_HELP_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_HELP_CB_);

void
_init_cb_KILLFOCUS_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_KILLFOCUS_CB_);

void
_init_cb_K_ANY_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_K_ANY_i);

void
_init_cb_LEAVEWINDOW_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_LEAVEWINDOW_CB_);

void
_init_cb_MAP_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MAP_CB_);

void
_init_cb_UNMAP_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_UNMAP_CB_);

void
_init_cb_ACTION_ff(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_ACTION_ff);

void
_init_cb_FOCUS_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_FOCUS_CB_i);

void
_init_cb_KEYPRESS_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_KEYPRESS_CB_ii);

void
_init_cb_MULTITOUCH_CB_iIIII(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MULTITOUCH_CB_iIIII);

void
_init_cb_SCROLL_CB_iff(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SCROLL_CB_iff);

void
_init_cb_TOUCH_CB_iiis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_TOUCH_CB_iiis);

void
_init_cb_WHEEL_CB_fiis(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_WHEEL_CB_fiis);

void
_init_cb_WOM_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_WOM_CB_i);

void
_init_cb_CLOSE_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_CLOSE_CB_);

void
_init_cb_COPYDATA_CB_si(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_COPYDATA_CB_si);

void
_init_cb_MDIACTIVATE_CB_(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MDIACTIVATE_CB_);

void
_init_cb_MOVE_CB_ii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_MOVE_CB_ii);

void
_init_cb_SHOW_CB_i(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_SHOW_CB_i);

void
_init_cb_TRAYCLICK_CB_iii(ih,action)
		Ihandle* ih;
		char* action;
	CODE:
		IupSetCallback(ih, action, (Icallback)internal_cb_TRAYCLICK_CB_iii);

